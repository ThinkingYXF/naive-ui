import{j as de,c as ue,a as K,o as ce}from"./index-DK-O6LKg.js";const le={xmlns:"http://www.w3.org/2000/svg","xmlns:xlink":"http://www.w3.org/1999/xlink",viewBox:"0 0 512 512"},be=de({name:"ArchiveOutline",render:function(r,d){return ce(),ue("svg",le,d[0]||(d[0]=[K("path",{d:"M80 152v256a40.12 40.12 0 0 0 40 40h272a40.12 40.12 0 0 0 40-40V152",fill:"none",stroke:"currentColor","stroke-linecap":"round","stroke-linejoin":"round","stroke-width":"32"},null,-1),K("rect",{x:"48",y:"64",width:"416",height:"80",rx:"28",ry:"28",fill:"none",stroke:"currentColor","stroke-linejoin":"round","stroke-width":"32"},null,-1),K("path",{fill:"none",stroke:"currentColor","stroke-linecap":"round","stroke-linejoin":"round","stroke-width":"32",d:"M320 304l-64 64l-64-64"},null,-1),K("path",{fill:"none",stroke:"currentColor","stroke-linecap":"round","stroke-linejoin":"round","stroke-width":"32",d:"M256 345.89V224"},null,-1)]))}});function fe(o){if(!o)return{};const r={};return o.trim().split(/[\r\n]+/).forEach(function(u){const c=u.split(":"),y=(c[0]||"").trim().toLowerCase(),f=(c[1]||"").trim();r[y]=f}),r}const pe=({url:o,method:r,headers:d,body:u,responseType:c,withCredentials:y,onDownloadProgress:f,onUploadProgress:_,onResponse:b,onNetworkError:q,onHeadersReceived:k})=>{const i=new XMLHttpRequest;i.open(r,o),i.withCredentials=y,i.responseType=c;for(const[s,I]of Object.entries(d))i.setRequestHeader(s,I);_&&i.upload.addEventListener("progress",s=>{_({lengthComputable:s.lengthComputable,percent:s.lengthComputable?s.loaded/s.total*100:0,loaded:s.loaded,total:s.total,detail:s,originalRequest:i})}),f&&i.addEventListener("progress",s=>{f({lengthComputable:s.lengthComputable,percent:s.lengthComputable?s.loaded/s.total*100:0,loaded:s.loaded,total:s.total,detail:s,originalRequest:i})});let v=null,S=()=>(v===null&&(v=fe(i.getAllResponseHeaders())),v);i.addEventListener("loadend",s=>{b({status:i.status,headers:S(),body:i.response},s)});const w=()=>{i.readyState===i.HEADERS_RECEIVED&&k&&k(S(),i),i.removeEventListener("readystatechange",w)};return i.addEventListener("readystatechange",w),i.addEventListener("error",s=>{q(s)}),i.send(u),{abort(){i.abort()}}};var p;(function(o){o.NETWORK="NETWORK",o.ABORTED="ABORTED",o.INVALID_JSON="INVALID_JSON",o.INVALID_CONVERSION="INVALID_CONVERSION",o.TIMEOUT="TIMEOUT",o.HTTP="HTTP",o.BAD_REQUEST="BAD_REQUEST",o.BROKEN_ON_AFTER_RESPONSE="BROKEN_ON_AFTER_RESPONSE",o.BROKEN_ON_BEFORE_REQUEST="BROKEN_ON_BEFORE_REQUEST",o.BROKEN_ON_INIT="BROKEN_ON_INIT",o.BROKEN_ON_RESPONSE_ERROR="BROKEN_ON_RESPONSE_ERROR",o.BROKEN_ON_NON_RESPONSE_ERROR="BROKEN_ON_NON_RESPONSE_ERROR",o.BROKEN_ON_HEADERS_RECEIVED="BROKEN_ON_HEADERS_RECEIVED"})(p||(p={}));function Ee(){const o=new Error;return o.__lylaError=!0,o}function h(o,r){const d=Ee();d.name=`LylaError[${o.type}]`,r&&(d.stack+=r),Object.assign(d,o);const u=()=>{const c=d;return{name:c.name,message:c.message,stack:c.stack,type:c.type,error:c.error,detail:c.detail,context:c.context,response:c.response,requestOptions:c.requestOptions,__lylaError:!0}};return d.spread=u,d}function he(o){return typeof o=="object"&&!!o&&"__lylaError"in o}function Oe(o,r){return ye(r)?r:r?o.replace(/\/+$/,"")+"/"+r.replace(/^\/+/,""):o}function ye(o){return/^([a-z][a-z\d+\-.]*:)?\/\//i.test(o)}function re(o){return o&&typeof o=="object"}function M(o,r){if(!r)return o;for(const[d,u]of Object.entries(r))u===void 0?delete o[d]:o[d.toLowerCase()]=typeof u=="string"?u:`${u}`;return o}function $(...o){let r={};for(const d of o)if(Array.isArray(d))Array.isArray(r)||(r=[]),r.push(...d);else if(re(d))for(let[u,c]of Object.entries(d))re(c)&&u in r&&(c=$(r[u],c)),r[u]=c;return r}const Re={100:"Continue",101:"Switching Protocols",102:"Processing",103:"Early Hints",200:"OK",201:"Created",202:"Accepted",203:"Non-Authoritative Information",204:"No Content",205:"Reset Content",206:"Partial Content",207:"Multi-Status",208:"Already Reported",226:"IM Used",300:"Multiple Choices",301:"Moved Permanently",302:"Found",303:"See Other",304:"Not Modified",305:"Use Proxy",307:"Temporary Redirect",308:"Permanent Redirect",400:"Bad Request",401:"Unauthorized",402:"Payment Required",403:"Forbidden",404:"Not Found",405:"Method Not Allowed",406:"Not Acceptable",407:"Proxy Authentication Required",408:"Request Timeout",409:"Conflict",410:"Gone",411:"Length Required",412:"Precondition Failed",413:"Payload Too Large",414:"URI Too Long",415:"Unsupported Media Type",416:"Range Not Satisfiable",417:"Expectation Failed",418:"I'm a teapot",421:"Misdirected Request",422:"Upprocessable Entity",423:"Locked",424:"Failed Dependency",425:"Too Early",426:"Upgrade Required",428:"Precondition Required",429:"Too Many Requests",431:"Request Header Fields Too Large",451:"Unavailable For Legal Reasons",500:"Internal Server Error",501:"Not Implemented",502:"Bad Gateway",503:"Service Unavailable",504:"Gateway TImeout",505:"HTTP Version Not Supported",506:"Variant Also Negotiates",507:"INsufficient Storage",508:"Loop Detected",510:"Not Extended",511:"Network Authentication Required"};function Ne(o){return Re[o]||""}function me(o){return 200<=o&&o<300}function _e(o,r,...d){const u=$(r,...d);async function c(f){var _,b,q,k,i,v,S,w,s;const I=f.context===void 0?u.context:f.context;let N=Object.assign({},f,{context:typeof I=="object"?JSON.parse(JSON.stringify(I)):I});async function m(t){var n,a;if(!((n=e.hooks)===null||n===void 0)&&n.onNonResponseError)try{for(const l of(a=e.hooks)===null||a===void 0?void 0:a.onNonResponseError){const O=l(t);O instanceof Promise&&await O}T(t)}catch(l){T(h({type:p.BROKEN_ON_NON_RESPONSE_ERROR,error:l,message:"`onNonResponseError` hook throws error",detail:void 0,response:void 0,context:t.context,requestOptions:e},void 0));return}else T(t)}try{if(!((_=u==null?void 0:u.hooks)===null||_===void 0)&&_.onInit)for(const t of u.hooks.onInit){const n=t(N);n instanceof Promise?N=await n:N=n}if(!((b=f==null?void 0:f.hooks)===null||b===void 0)&&b.onInit)for(const t of f.hooks.onInit){const n=t(N);n instanceof Promise?N=await n:N=n}}catch(t){const n=h({type:p.BROKEN_ON_INIT,message:"`onInit` hook throws error",detail:void 0,error:t,response:void 0,context:N.context,requestOptions:N},void 0);throw m(n),n}let e=$(u,N);e.method=(q=e.method)===null||q===void 0?void 0:q.toUpperCase(),e.responseType=f.responseType||"text",e.url=e.url||"",e.baseUrl&&(e.url=Oe(e.baseUrl,e.url));let P;try{P=(k=new Error().stack)===null||k===void 0?void 0:k.replace(/^Error/,"")}catch{}if(e.query){const t=new URLSearchParams;for(const[a,l]of Object.entries(e.query))if(Array.isArray(l))for(const O of l)t.append(a,O.toString());else l!=null&&t.append(a,l.toString());const n=t.toString();if(e.url.includes("?")){const a=h({type:p.BAD_REQUEST,message:"`options.query` can't be set if `options.url` contains '?'",detail:void 0,error:void 0,response:void 0,context:e.context,requestOptions:e},void 0);throw m(a),a}n.length&&(e.url=e.url+"?"+n)}if(!((i=e.hooks)===null||i===void 0)&&i.onBeforeRequest)try{for(const t of(v=e.hooks)===null||v===void 0?void 0:v.onBeforeRequest){const n=t(e);n instanceof Promise?e=await n:e=n}}catch(t){const n=h({type:p.BROKEN_ON_BEFORE_REQUEST,message:"`onBeforeRequest` hook throws error",detail:void 0,error:t,response:void 0,context:N.context,requestOptions:e},void 0);throw m(n),n}if(e.json!==void 0){if(e.body!==void 0){const t=h({type:p.BAD_REQUEST,message:"`options.json` can't be used together with `options.body`. If you want to use `options.json`, you should left `options.body` as `undefined`",detail:void 0,error:void 0,response:void 0,context:e.context,requestOptions:e},void 0);throw m(t),t}e.body=JSON.stringify(e.json)}const{timeout:C,url:se="",method:G="get",body:W,responseType:V="text",withCredentials:ie=!1,signal:j,onUploadProgress:z,onDownloadProgress:X}=e;async function A(t){var n,a;if(!((n=e.hooks)===null||n===void 0)&&n.onResponseError)try{for(const l of(a=e.hooks)===null||a===void 0?void 0:a.onResponseError){const O=l(t,D);O instanceof Promise&&await O}T(t)}catch(l){const O=h({type:p.BROKEN_ON_RESPONSE_ERROR,error:l,message:"`onResponseError` hook throws error",detail:void 0,response:void 0,context:t.context,requestOptions:e},void 0);m(O);return}else T(t)}let Z,T,D;const g={};M(g,u.headers),M(g,e.headers),e.json!==void 0&&(g["content-type"]=(S=g["content-type"])!==null&&S!==void 0?S:"application/json"),g.accept=(w=g.accept)!==null&&w!==void 0?w:"*/*",e.headers=g;let H=!1,Y=!1;function ee(){H=!0,Y||F()}function F(){Y=!0,j&&j.removeEventListener("abort",te)}const ae=new Promise((t,n)=>{Z=t,T=a=>{H||(ee(),n(a))},D=a=>{H||(ee(),n(a))}});let B=!1;function te(){if(B)return;B=!0;const t=h({type:p.ABORTED,message:"Request aborted",detail:void 0,error:void 0,response:void 0,context:e.context,requestOptions:e},P),n=()=>oe.abort();A(t).then(n).catch(n)}j&&j.addEventListener("abort",te);let L=!1;const J=(s=e.hooks)===null||s===void 0?void 0:s.onHeadersReceived,oe=o({url:se,method:G,body:W,json:e.json,headers:g,responseType:V,withCredentials:ie,extraOptions:e.extraOptions,onNetworkError(t){L=!0,F();const n=h({type:p.NETWORK,message:"Network error",detail:t,error:void 0,response:void 0,context:e.context,requestOptions:e},P);A(n)},onDownloadProgress:X?t=>{X(Object.assign(Object.assign({},t),{requestOptions:e}))}:void 0,onUploadProgress:z?t=>{z(Object.assign(Object.assign({},t),{requestOptions:e}))}:void 0,onHeadersReceived:J?(t,n)=>{if(!B&&!L&&J){const a=M({},t);try{for(const l of J)l({headers:a,requestOptions:e,originalRequest:n},D)}catch(l){const O=h({type:p.BROKEN_ON_HEADERS_RECEIVED,message:"`onHeadersReceived` hook throws error",detail:void 0,response:void 0,error:l,context:e.context,requestOptions:e},void 0);m(O);return}}}:void 0,async onResponse(t,n){var a;if(B||L)return;F();let l,O=!1,Q,U;const ne=Ne(t.status);let R={context:e.context,requestOptions:e,status:t.status,statusText:ne,headers:M({},t.headers),body:t.body,detail:n,set json(E){O=!0,l=E},get json(){if(O)return l;if(V!=="text"){const E=h({type:p.INVALID_CONVERSION,message:`Can not convert ${V} to JSON`,detail:void 0,error:void 0,response:R,context:R.context,requestOptions:e},void 0);throw m(E),E}if(Q===void 0)try{return Q=JSON.parse(t.body)}catch(E){U=E}else return Q;if(U){const E=h({type:p.INVALID_JSON,message:U.message,detail:void 0,error:U,context:R.context,response:R,requestOptions:e},void 0);throw m(E),E}}};if(!me(t.status)){const E=`${t.status} ${ne}`,x=h({type:p.HTTP,message:`Request failed with ${E}`,detail:void 0,error:void 0,response:R,context:e.context,requestOptions:e},P);A(x);return}if(!((a=e.hooks)===null||a===void 0)&&a.onAfterResponse)try{for(const E of e.hooks.onAfterResponse){const x=E(R,D);x instanceof Promise?R=await x:R=x}}catch(E){const x=h({type:p.BROKEN_ON_AFTER_RESPONSE,message:"`onAfterResponse` hook throws error",detail:void 0,response:R,error:E,context:R.context,requestOptions:e},void 0);m(x);return}Z(R)}});if(C&&setTimeout(()=>{if(H)return;oe.abort(),B=!0;const t=h({type:p.TIMEOUT,message:C?`Timeout of ${C}ms exceeded`:"Timeout exceeded",detail:void 0,error:void 0,response:void 0,context:e.context,requestOptions:e},P);A(t)},C),!e.allowGetBody&&G==="GET"&&W){const t=h({type:p.BAD_REQUEST,message:"Can not send a request with body in 'GET' method.",error:void 0,response:void 0,detail:void 0,context:e.context,requestOptions:e},void 0);throw m(t),t}return ae}function y(f){return(_,b)=>c(Object.assign(Object.assign({},b),{method:f,url:_}))}return{lyla:Object.assign(c,{get:y("get"),post:y("post"),put:y("put"),patch:y("patch"),head:y("head"),delete:y("delete"),options:y("options"),trace:y("trace"),connect:y("connect"),get errorType(){return{}}}),isLylaError(f){return he(f)}}}const{lyla:ve}=_e(pe,{context:void 0});export{be as A,ve as l};
